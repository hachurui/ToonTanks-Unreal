New Lecturer. Has some overlapping info, but hey, consider it review! :D
5.1 Intro
Section Plan:
Create a tank that can move through the world
Handle input (WASD, Mouse)
Create enemy turret class
Fire functionality with projectiles
Health, Damage, and destruction to the game
Special Effects (smoke, explosion, sounds)
Winning/losing conditions with HUD display

5.2: Pawn Class Creation
Will have two pawns, one thats the tank we control and one that's the enemy turrets.
These pawns will inherit from a BasePawn

Unreal class diffs
Actor:
 - Can be placed in the world
 - Can have a visual representation
Pawn:
 - Inherits from Actor
 - Can be possessed by a controller
 - Handles movement input
Character:
 - Inherits from Pawn
 - Has character specific features
  * Character Movement, Component, etc.
  * Movement modes (flying)
  * Good for bipedal characters

5.3: Components
Components are visual and physics representations. They either meshes that actually appear in the world or physical locations and area that provide data to physic representation, such as where a bullet spawns or how collision works.
Components can be attached to each other
Components have root components that store the transform information.

RootComponent is a property of the Actor class. It's a USceneComponent, so it has a transform, but no visual representation.

A RootComponent can be reassigned with some other object whose type derives from scene component.

Plan is to reassign the root component to a UCapsuleComponent to exist has our location. To this we attach the BaseMesh and TurretMesh (UStaticMeshComponent) for visual representation and at the end of the TurretMesh's turret we attach a USceneComponent ProjectileSpawnPoint.

5.4: Forward Declaration
Both the player and enemies with all have the following characteristics:
	Base Mesh, Turret Mesh, Capsule, Projectile Spawn Point
BasePawn will have these at its properties

	So when we're making our BasePawn class, when we define the capsule component it will need, its only going to a pointer to (class) UCapsuleComponent. Due to it just being a pointer, we can put "class" in front of it's declaration to in practice promise the compile this is a class that exists in an effort to avoid including the UCapsuleComponent.h file to the BasePawn.h file and instead include it in BasePawn.cpp. This is just good practice for performance.
	You do need the header file to construct an object, access members, or for inheritance, but if you only need to declare pointers to a class type, you can just forward declare as describe previously as best practice.

5.5: Constructing the Capsule
CreateDefaultSubobject<datatype>(TEXT("nameofobj");
Example: CreateDefaultSubobject<datatype>(TEXT("Cool Mesh"));
returns address of newly created component

Making a UCapsuleComponent the RootComponent:
CapsuleComp = CreateDefaultSubobject<UCapsuleComponent>(TEXT("Capsule Collider"));
RootComponent = CapsuleComp;

5.6: Static Mesh Components
Pretty much only important thing was about creating a default subobject and attaching it to different components, as so:

BaseMesh = CreateDefaultSubobject<UStaticMeshComponent>(TEXT("Base Mesh"));
BaseMesh->SetupAttachment(RootComponent);
TurretMesh = CreateDefaultSubobject<UStaticMeshComponent>(TEXT("Turret Mesh"));
TurretMesh->SetupAttachment(BaseMesh);
ProjectileSpawnPoint = CreateDefaultSubobject<USceneComponent>(TEXT("Spawn Point"));
ProjectileSpawnPoint->SetupAttachment(TurretMesh);

5.8: Instance vs Default
Went over UPROPERTY specifiers such as (EditAnywhere) and (VisibleInstanceOnly).
InstanceOnly is only visible/anywhere when interacting with specific instances of a blueprint, such as in the level editor, and not in the blueprint editor.
The opposite is DefaultsOnly.

5.9:Editing Exposed Variables
To expose variables to the blueprint event graph for reading and writing, you can add (BlueprintReadWrite).
For reading only, (BlueprintReadOnly).
You can add multiple specifiers such as (EditAnywhere, BlueprintReadWrite).

5.10: Exposing the Components
Say I have a private property of a class, but I want it to be editable from the blueprint event editor. I would need somethinglike this:
UPROPERTY(BlueprintReadWrite, meta = (AllowPrivateAccess = "true"))

Can add categories to UPROPERTY specifiers such as:
UPROPERTY(Category = "Category Name")

5.11: Creating Child C++ Class
What will the tank need that npc controlled towers will not?
Camera and spring arm. Type UCameraComponent and USpringArmComponent.

5.12: Possessing The Pawn
Just informed you can auto possess the tank (or any) pawn through the level editors detail window as well as the blueprint editor's.

5.13 User Input
Axis Mappings

So Unreal has updated their input system and the method discussed in the course is outdated. These are MY notes B)

***************ENHANCED INPUT SECTION***************
First step is to open the ProjectName.Build.cs in the source folder. There will be a list of dependencies being defined,m such as "Core", "CoreUObject", etc. If its not already there, add "EnhancedInput" to this list.

When playing, press ~ for console commands and "ShowDebug EnhancedInput" for debugging input.

So, we have a .h and .cpp for character we intend to control. In the header forward declare:
class UInputMappingContext;
class UInputAction;
struct FInputActionValue;

and add a property:
UPROPERTY(EditAnywhere, Category = "Input", meta = (AllowPrivateAccess = "true"))
UInputMappingContext* DefaultMappingContext;

and an override:
virtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;

In cpp, include:
#include "EnhancedInputComponent.h"
#include "EnhancedInputSubsystems.h"
#include "InputActionValue.h"

Then in void ACharacter::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent):
Super::SetupPlayerInputComponent(PlayerInputComponent);
    APlayerController* PlayerController = Cast<APlayerController>(GetController());
    if(PlayerController)
    {
        UEnhancedInputLocalPlayerSubsystem* Subsystem = ULocalPlayer::GetSubsystem<UEnhancedInputLocalPlayerSubsystem>(PlayerController->GetLocalPlayer());
        if (Subsystem)
        {
            Subsystem->AddMappingContext(DefaultMappingContext, 0);
        }
    }

There's a lot there, but something very worth pointing out is this line:
 Subsystem->AddMappingContext(DefaultMappingContext, 0)
That adds a mapping context to the subsystem (obviously), but what's the 0? The 0 is representative of the priority of the mapping context. This is in the case of having two mapping contexts active simultaneously that share an input. The mapping context with the highest priority (the lowest number) will be used.

Other noteworthy Sybsystem functions are:
Subsystem->RemoveMappingContext(DefaultMappingContext)
Subsystem->HasMappingContext(DefaultMappingContext)

Hopefully the uses of these functions are self apparent.

After all of this, in the details window of your desired control object, search for input and select your default input mapping context.

Each action will need to be declared in the header of controlled object. So for move:
UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Input", meta = (AllowPrivateAccess = "true"))
UInputAction* MoveAction;

Then in CPP, under where you add mapping context (outside the if), you bind the action as so:
UEnhancedInputComponent* EnhancedInputComponent = Cast<UEnhancedInputComponent>(PlayerInputComponent);
if(EnhancedInputComponent)
{
    EnhancedInputComponent->BindAction(MoveAction, ETriggerEvent::Triggered, this, &ATank::Move);
}