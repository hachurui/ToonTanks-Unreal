New Lecturer. Has some overlapping info, but hey, consider it review! :D
5.1 Intro
Section Plan:
Create a tank that can move through the world
Handle input (WASD, Mouse)
Create enemy turret class
Fire functionality with projectiles
Health, Damage, and destruction to the game
Special Effects (smoke, explosion, sounds)
Winning/losing conditions with HUD display

5.2: Pawn Class Creation
Will have two pawns, one thats the tank we control and one that's the enemy turrets.
These pawns will inherit from a BasePawn

Unreal class diffs
Actor:
 - Can be placed in the world
 - Can have a visual representation
Pawn:
 - Inherits from Actor
 - Can be possessed by a controller
 - Handles movement input
Character:
 - Inherits from Pawn
 - Has character specific features
  * Character Movement, Component, etc.
  * Movement modes (flying)
  * Good for bipedal characters

5.3: Components
Components are visual and physics representations. They either meshes that actually appear in the world or physical locations and area that provide data to physic representation, such as where a bullet spawns or how collision works.
Components can be attached to each other
Components have root components that store the transform information.

RootComponent is a property of the Actor class. It's a USceneComponent, so it has a transform, but no visual representation.

A RootComponent can be reassigned with some other object whose type derives from scene component.

Plan is to reassign the root component to a UCapsuleComponent to exist has our location. To this we attach the BaseMesh and TurretMesh (UStaticMeshComponent) for visual representation and at the end of the TurretMesh's turret we attach a USceneComponent ProjectileSpawnPoint.

5.4: Forward Declaration
Both the player and enemies with all have the following characteristics:
	Base Mesh, Turret Mesh, Capsule, Projectile Spawn Point
BasePawn will have these at its properties

	So when we're making our BasePawn class, when we define the capsule component it will need, its only going to a pointer to (class) UCapsuleComponent. Due to it just being a pointer, we can put "class" in front of it's declaration to in practice promise the compile this is a class that exists in an effort to avoid including the UCapsuleComponent.h file to the BasePawn.h file and instead include it in BasePawn.cpp. This is just good practice for performance.
	You do need the header file to construct an object, access members, or for inheritance, but if you only need to declare pointers to a class type, you can just forward declare as describe previously as best practice.

5.5: Constructing the Capsule
CreateDefaultSubobject<datatype>(TEXT("nameofobj");
Example: CreateDefaultSubobject<datatype>(TEXT("Cool Mesh"));
returns address of newly created component

Making a UCapsuleComponent the RootComponent:
CapsuleComp = CreateDefaultSubobject<UCapsuleComponent>(TEXT("Capsule Collider"));
RootComponent = CapsuleComp;

5.6: Static Mesh Components
Pretty much only important thing was about creating a default subobject and attaching it to different components, as so:

BaseMesh = CreateDefaultSubobject<UStaticMeshComponent>(TEXT("Base Mesh"));
BaseMesh->SetupAttachment(RootComponent);
TurretMesh = CreateDefaultSubobject<UStaticMeshComponent>(TEXT("Turret Mesh"));
TurretMesh->SetupAttachment(BaseMesh);
ProjectileSpawnPoint = CreateDefaultSubobject<USceneComponent>(TEXT("Spawn Point"));
ProjectileSpawnPoint->SetupAttachment(TurretMesh);

5.8: Instance vs Default
Went over UPROPERTY specifiers such as (EditAnywhere) and (VisibleInstanceOnly).
InstanceOnly is only visible/anywhere when interacting with specific instances of a blueprint, such as in the level editor, and not in the blueprint editor.
The opposite is DefaultsOnly.

5.9:Editing Exposed Variables
To expose variables to the blueprint event graph for reading and writing, you can add (BlueprintReadWrite).
For reading only, (BlueprintReadOnly).
You can add multiple specifiers such as (EditAnywhere, BlueprintReadWrite).

5.10: Exposing the Components
Say I have a private property of a class, but I want it to be editable from the blueprint event editor. I would need somethinglike this:
UPROPERTY(BlueprintReadWrite, meta = (AllowPrivateAccess = "true"))

Can add categories to UPROPERTY specifiers such as:
UPROPERTY(Category = "Category Name")

5.11: Creating Child C++ Class
What will the tank need that npc controlled towers will not?
Camera and spring arm. Type UCameraComponent and USpringArmComponent.

5.12: Possessing The Pawn
Just informed you can auto possess the tank (or any) pawn through the level editors detail window as well as the blueprint editor's.

5.13 User Input
Axis Mappings

So Unreal has updated their input system and the method discussed in the course is outdated. These are MY notes B)

***************ENHANCED INPUT SECTION***************
First step is to open the ProjectName.Build.cs in the source folder. There will be a list of dependencies being defined,m such as "Core", "CoreUObject", etc. If its not already there, add "EnhancedInput" to this list.

When playing, press ~ for console commands and "ShowDebug EnhancedInput" for debugging input.

So, we have a .h and .cpp for character we intend to control. In the header forward declare:
class UInputMappingContext;
class UInputAction;
struct FInputActionValue;

and add a property:
UPROPERTY(EditAnywhere, Category = "Input", meta = (AllowPrivateAccess = "true"))
UInputMappingContext* DefaultMappingContext;

and an override:
virtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;

In cpp, include:
#include "EnhancedInputComponent.h"
#include "EnhancedInputSubsystems.h"
#include "InputActionValue.h"

Then in void ACharacter::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent):
Super::SetupPlayerInputComponent(PlayerInputComponent);
    APlayerController* PlayerController = Cast<APlayerController>(GetController());
    if(PlayerController)
    {
        UEnhancedInputLocalPlayerSubsystem* Subsystem = ULocalPlayer::GetSubsystem<UEnhancedInputLocalPlayerSubsystem>(PlayerController->GetLocalPlayer());
        if (Subsystem)
        {
            Subsystem->AddMappingContext(DefaultMappingContext, 0);
        }
    }

There's a lot there, but something very worth pointing out is this line:
 Subsystem->AddMappingContext(DefaultMappingContext, 0)
That adds a mapping context to the subsystem (obviously), but what's the 0? The 0 is representative of the priority of the mapping context. This is in the case of having two mapping contexts active simultaneously that share an input. The mapping context with the highest priority (the lowest number) will be used.

Other noteworthy Sybsystem functions are:
Subsystem->RemoveMappingContext(DefaultMappingContext)
Subsystem->HasMappingContext(DefaultMappingContext)

Hopefully the uses of these functions are self apparent.

After all of this, in the details window of your desired control object, search for input and select your default input mapping context.

Each action will need to be declared in the header of controlled object. So for move:
UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Input", meta = (AllowPrivateAccess = "true"))
UInputAction* MoveAction;

Then in CPP, under where you add mapping context (outside the if), you bind the action as so:
UEnhancedInputComponent* EnhancedInputComponent = Cast<UEnhancedInputComponent>(PlayerInputComponent);
if(EnhancedInputComponent)
{
    EnhancedInputComponent->BindAction(MoveAction, ETriggerEvent::Triggered, this, &ATank::Move);
}

5.14: Local Offset
Moving the tank.. Adding a local offset.
Local space vs world space
Actors have their own local directions, usually not the same as the world direction.
You'd often want to move an actor according to their local direction, so if you move an actor forward, you'd want it to be the actor's forward, not the world's.
This is done through AActor::AddActorLocalOffset().
Parameters are FVector DeltaLocation, bool bSweep, FHitResult* OutSweepHitResult, ETeleportType Teleport.

So, in the context of our tank pawn, to move it in the ATank::Move() function, we put.
FVector DeltaLocation(0.f); //makes an fvector of all 0.0
DeltaLocation.X = pValue.Get<float>(); //changes the x of deltalocation to the value passed in as a float, so if its a bool, this just moves it as 1. (NOTE: MAKE SURE TO ADD CORRECT MODIFIERS BASED ON KEY IN THE INPUT CONTEXT MENU.)
AddActorLocalOffset(DeltaLocation);

5.15: Movement Speed
So there's a problem with deltatime in this scenario. Tank inherits from BasePawn. BasePawn's tick function is where deltatime is automatically determined, and the tick function would have to pass deltatime as a parameter in a function call. However, Tank is where our move function in, and it's called from an event rather than in a tick function or anything similar.
Well, we gotta have an alternative to access deltatime, right?
UGameplayStatics::GetWorldDeltaSeconds(WorldContextObject)
WorldContextObject can be a reference to any object in the World you're working in (a World being the highest level object of our game). So, in the case of within the context of the Move() function, we can just pass GetWorldDeltaSeconds(this)

5.16 Local Rotation
Sweeping:
Engine function that checks the distance between an object's current position and there proposed new position for if there would be an overlap between to objects/a collision.
AddActorLocalOffset(DeltaLocation, true);
That true sets it to sweep.

Changing local rotation is fairly identical to local location.
Compare:
FVector DeltaLocation(0.f);
float MoveDirection = pValue.Get<float>();
float DeltaTime = UGameplayStatics::GetWorldDeltaSeconds(this);
DeltaLocation.X = MoveDirection*Speed*DeltaTime;
AddActorLocalOffset(DeltaLocation, true);
Versus:
FRotator DeltaRotation = FRotator::ZeroRotator;
float DeltaTime = UGameplayStatics::GetWorldDeltaSeconds(this);
DeltaRotation.Yaw = pValue.Get<float>()*DeltaTime*TurnRate;
AddActorLocalRotation(DeltaRotation, true);

5.17: Casting
So here's we're trying to grab the controller of the tank pawn and store it as an APlayerController*. Problem is the GetController() function of pawns return a type AController, which is higher on the inheritance hierarchy. How remedy this?
CASTING WOOO!!! YEAAAAAH!!!!!
Casting is pretty much a promise to the compiler (in the same way forward declaring with "class" in a header is) that what we're casting is the datatype we're saying it is. If it isn't, cast will return null and we fail the cast.
Cast<DataTypeWeCastTo>(PointerToObject);
Cast<APlayerController>(GetController());

5.18: Using the Mouse Cursor
We perform a Line Trace, hitting something is a trace hit, the information of the hit stored in a struct FHitResult. Information stored include Hit Location and Hit Actor among other things.
We trace using "Collision Channels" often times in the ECC_Visibility channel, ECollisionChannel::ECC_Visibility
Hit events registered on objects set to Block the Visibility Channel.

So to get a location from our cursor, what's happening is we're performing a line trace from the camera to the determine location, which returns a FHitResult.

APlayerController::GetHitResultUnderCursor()
Parameters: ECollisionChannel TraceChannel, bool bTraceComplex, FHitResult& HitResult)
The HitResult passed in is an out parameter.